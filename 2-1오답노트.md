# 2-1오답노트

1. X

2. X

3. X 

4. 비절차적 데이터 조작어는 사용자가 무슨 데이터를 원하는 지만을 명세하지만, 절차적 데이터 조작어는 어떻게 데데이터를 접근해야하는지 명세. 

   절차적: PL/SQL (오라클), T-SQL

   호스트 프로그램속에 삽입되어 사용하는 DML은 데이터 부속어 라고도 함.

5. X

6. X

7. SQLserver에서는 컬럼 여러개 한번에 수정 X

8. x

9. PK,FK 1개씩 구성된 테이블에서 FK의 부모테이블 PK가 지워지면 CASCADE에 의해 FK도 지워져서 해당 테이블도 두 건 모두 삭제 된다고 가정.

10. UNIQUE는 NULL가능

11. 테이블명,칼럼명은 무조건 문자로 시작

12. X

13. X

14. FK는 NULL 가질 수 있다.

    외래키는 참조 무결성 제약 받을 수 있다.

15. check제약조건은 데이터 무결성을 위해 특정 컬럼에 설정.

    기본키는 반드시 테이블 당 하나의 제약만을 정의 할 수있다.

16. x

17. **참조 무결성**

    \- 기본 키와 참조 키 간의 관계가 항상 유지됨을 보장합니다.

    \- 참조되는 테이블의 행을 이를 참조하는 참조키가 존재하는 한 삭제될 수 없고, 기본키도 변경될 수 없습니다.

    delete action cascade,setnull ,set default, restrict 

18. 이름 바꾸는건 그냥 rename만 하면 돼

19. Fk delete action: cascade ,setnull, set default, restrict

    insert action :

    automatic:마스테 테이블에 pk가 없는 경우 마스터 pk생성 후 child 입력

    dependent : pk 없으면 child fk 입력 허용 x

20. X

21. varchar에 그냥 숫자 넣어도 ok 'q&a' 이런것도 가능.

    pk업데이트 가능한듯

22. 4번 몰랐는데 보니 고객 id는 not null인데 제약조건 추가 하면서 c002 지우면 setnull로 바꾸는 조건이여서 setnull 넣을 수 없음. 

23. truncate와 drop 은 로그를 남기지 않음

    delete는 로그 남기나봄.

24. x

25. delete: 데이터 삭제, 디스크 초기화 안함 (제일 약함)

    사용자가 커밋, DML,commit이전 롤백 가능

    truncate: 데이터 삭제, 디스크 초기화 (중간), 롤백 불가능, DDL, 최초테이블,오토커밋.

    drop : 데이터, 디스크 ,테이블 스키마 정의도 초기화  (보통),DDL, 정의자체 삭제,오토커밋.

26.  25와 동일

27. 트랜잭션 원자성: 모아니면 도

    일관성: 전 잘못 없, 후 잘못 없

    고립성 : 다른 트랜잭션의 영향 x

    지속성: 트랜잭션 수행하면 갱신한 내용 영구저장.

28. 격리성 낮은경우 발생하는 문제

    dirty read- 다른 트랜잭션에 의해 수정되었지만 아직 커밋되지 않은 데이터를 읽는것

    non-repeatable read 한 트랜잭션 내에서 같은 쿼리 두 번 수행했는데 그 상이ㅔ 다른 트랜잭션이 수정 또는 삭제하는 바람에 두 쿼리 결과가 다른것

    phantom-read: 같은 쿼리 두 번 수행했는데 첫번째 쿼리에서 없던 유령 레코드가 두번쨰 쿼리에서 나타나는 현상.

29. oracle에서는 ddl문장 수행후 autocommit

    sqlS에서는 ddl문장 수행 후 오토커밋 안함.

    oracle에서 ddl 수행은 내부적을 트랜잭션 종료

30. x

31. 트랜잭션 commit 안하면 아직 저장안된것

32. x

33. x

34. x

35. x

36. x

37. 오라클 - ''(공백) = NULL 로 인식
    SQL - ''(공백) = ''(공백) 로 인식

38. x

39. x

40. 다중행 함수든 단일행 함수든 단일 값만을 반환

    1:m조인이라고 하더라도 m쪽에서 출력된 행이 단일행 함수의 입력값으로 사용돠므로 사용 가능.

41.???

42. x
43. x
44. x
45. x
46. x
47. 0으로 나누는 연산은 에러발생
48. coalesce는 row단위로 검증
49. x
50. 집계함수는 null 제외 단 count(*)는 포함.
51. x
52. x

53. groupby없이도 having 쓸 수 있다.

54. x

55. orderby 할 떄 숫자가 낮은게 먼저 출력된다.(오름차순)

    ORDER BY(CASE WHEN ID =999 THEN 0 ELSE ID END)

    오라클에서는 NULL이 가장 크고 SQLS에서는 NULL이 가장 작음.

56.  2번도 select 에 '년'컬럼이 없어서 이걸로 정렬하는것은 옳지 않지만 오라클에서는 행기반 이기 때문에 전체 컬럼을 메모리에 로드함으로써 select에 없는 컬럼으로도 종렬 가능.

    단, inline view에서 select 에 정의되지 않은 컬럼은 사용할 수 없다.

    3번은 group by를 할 떄에는 group by한 컬럼과 사용하려는 집계함수로 다시 테이블이 만들어지기 때문에 새로 생성된 테이블에는 '년' 컬럼 존재 x

    4번 같은 경우는 지역 ,매출금액 ,지역 별 레코드 수 3개를 가진 가상 테이블이 만들어진다.

    group by하면 가상 테이블 만듬!

57. groupby를 사용하면 orderby절에 집계함수를 사용할 수도 있다.

    orderby절에 칼럼명 대신 alias명이나 컬럼 순서를 나타내는 정수를 사용할 수 있고 혼용하여 사용도 가능하다.

58.x

59.from- where - groupby -having -select - orderby

60. SQLS 의 TON N 질의문에서 (N)에 해당하는 값이 동일한 경우 함께 출력되도록 하는 WITH TIES옵션을 ORDERBY절과 같이사용.

61. 여러테이블N개 로부터 원하는 데이터를 조회하기 위해서는 최소 N-1개의 조인 필요

62. X

63. DBMS 옵티마이저는 from 절에 나열된 테이블이 아무리 많아도 항상 2개의 테이블씩 짝을 지어 join을 수행한다. 

    설계상의 이유로 non-equi-join을 수행이 불가능할 수도 있다.



64.X